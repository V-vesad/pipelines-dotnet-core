# For full annotated example, please visit
#   https://onebranch.visualstudio.com/Pipeline/_wiki/wikis/Pipeline.wiki?wikiVersion=GBwikiMaster&pagePath=%2FWelcome%20to%20OneBranch%20Pipeline%2FCross%20Platform%20Cloud%20Delivery%20Pipeline%20(CDPx)%2FYAML%20Format%2FAnnotated%20Example

# The following section is a metadata section that describes what kind of environment this pipeline should be executing in. Some of the
# information is redundant and will be removed in a future version.
environment:
  host:
    os: 'windows'                                                       # used to verify at runtime that correct host pool is being used
    flavor: 'server'                                                    # not used and will be removed in future
    version: '2016'                                                     # not used and will be removed in future
  runtime:
    provider: 'appcontainer'                                            # Currently only appcontainer is supported
                                                                        # future will bring oscontainer and virtualmachine
    image: 'cdpxwintest.azurecr.io/global/windows/rs5/vse20199-rs5-test0:latest' # This is the image that your pipeline will run in.
                                                                        # For (appcontainer), Docker Hub public Microsoft repository images
                                                                        # can be used.
                                                                        # Example microsoft/dotnet:1.1.1-sdk-nanoserver.
                                                                        # Or the CDP team vended and custom images can be used.
                                                                        # These are cdpxwin.azurecr.io/user/<user-image-name> or
                                                                        # cdpxwin.azurecr.io/legacy/samples/wsmobile (for now).
    source_mode: 'link'                                                 # 'copy' or 'link'. There is a known bug for npm and ruby on some of
                                                                        # our images that linked folder in container may cause errors on
                                                                        # these languages, for that case, use 'copy' here and pipeline will
                                                                        # full copy source into container from host before each step and full
                                                                        # copy out back to host after each step. It may be very slow if you
                                                                        # have a giant repository.

workspace_options:                  # Metadata section
  enable_legacy_networking: true    # Default is false. If false, only the Restore stage enables network connectivity to the user build container. 
                                    # If true, all stages enable network connectivity to user build container.

# The following is a metadata section that describes the versioning scheme and basic version datacenter to use. This data will be used to
# generate content in the .version folder for use by your custom versioning steps.
# In fact, in this sample, a file named .version\PipelineAssemblyInfo.cs will be generated that contains the following code (ignore the
# actual versions because those are dummy values).
#
# // This is a CDPX pipeline generated file
# using System.Reflection;
# [assembly: AssemblyVersion("1.0.060517.1000")]
# [assembly: AssemblyFileVersion("1.0.060517.1000")]
# [assembly: AssemblyInformationalVersion("1.0.060517.1000-test-31f791f1")]
#
# The key point is that this file is not checked in by CDPX. So, we check in a dummy file with similar content and add this file as a compile
# item with a link. When the code is built in CDPX, the file is first overwritten with actual version numbers. Thus, when the code compiles,
# the new version numbers are picked up.
#
# Obviously, this may not work for everyone. So, in addition to these template files, CDPX writes out several info files whose content is some
# part of the version number. Which part is hinted at by the name of the file.
# For example, package.semantic.info will contain patch semantic version number in the form 1.0.MMddyyrrrr-tag-commit.
version:
  name: 'Generate Version file'                                         # The uber name to attach to the artifacts generated by this pipeline.
                                                                        # Currently unused, but will be used in the future to refer to the
                                                                        # artifacts as a group by name.
  major: 1                                                              # The major version number.
  minor: 0                                                              # The minor version number
# tag: 'alpha'                                                          # Tag to use for semantic versioning.
  system: 'buildrevision'                                               # Versioning scheme to use.
                                                                        # patch         - 1.0.MMddyyrrrr will be generated
                                                                        # buildrevision - 1.0.MMddyy.rrrr will be generated.

# The following is an optional user defined stage. If the version numbers generated by the pipeline are not compatible with your pre-existing
# model, then you can customize your version number any way you want by executing any scripts in this stage. This is a logical organization;
# you can do this even in build stage but we will be adding support to make VSTS show the custom version number in the future.
# Eventually, network access will be limited or cut-off in this stage.
versioning:
  commands:  # This is a sequence of script files to be executed one after another in the order they appear here.
             # We are not doing anything here. In fact, we could have omitted the versioning stage entirely.
    - !!defaultcommand
      name: 'Set Version'
      command: '.pipelines\versioning.cmd'

signing_options:
  profile: 'internal_azure_service'

static_analysis_options:
  fxcop_options:
    disable_tool_scan: true
  policheck_options:
    disable_tool_scan: true
  moderncop_options:
    disable_tool_scan: true
  binskim_options:
    disable_tool_scan: true
    files_to_scan:
      - from: 'src\Services\Microsoft.Synapse.Insights.SfApplication\pkg'
        include:
          - '**/Microsoft.Synapse.Insights.Notification.SignalR.exe'

# Restore nuget packages.
# If workspace_options.enable_legacy_networking = false, networking is enabled only in this stage (doing a restore in any other stage will fail).
restore:
  commands: # This is a sequence of script files to be executed one after another in the order they appear here.
    - !!defaultcommand                            # There are three types of commands, buildcommand, testcommand and defaultcommand.
                                                  # The only difference is that they collect different types of artifacts.
                                                  # buildcommand - run a build script, collect artifacts, specify files to sign and logs.
                                                  # defaultcommand - run any script, collect logs only.
                                                  # testcommand - run a test script, collect logs, test results and code coverage files.
                                                  #               and associate with the build.
      name: 'Generate Nuget Config'
      command: '.pipelines\nugetConfig.cmd'

    - !!defaultcommand
      name: 'Restore Nuget Packages'
      command: '.pipelines\restoreNugetPackages.cmd'
      arguments: '..\src\Microsoft.Synapse.Insights.SfApplication.sln'

# An optional user defined stage for performing any compilation, code generation etc.
# All files in the artifacts sections will be collected, saved off and signed.
# The signed files will be restored back to the original locations before the next stage is invoked.
# Eventually, network access will be limited or cut-off in this stage.
build:
  commands: # This is a sequence of script files to be executed one after another in the order they appear here.
    - !!defaultcommand
      name: 'Build The Code'                      # This is name for this step. The step name will be in logs
                                                  # and in the future, will be associated with metrics, timelines,
                                                  # journal etc.
      command: '.pipelines\build.cmd'             # A root relative path to the script to execute. Any console output
                                                  # will be automatically pushed to VSTS logs. Any files explicitly
                                                  # written to file can be collected via the logs list.
                                                  # Note that the best way to code these scripts is such that they run on a developer
                                                  # desktop. Invariably, if you can get it working no your dev desktop, it should work in the
                                                  # CDP pipeline.
      # logs:                                     # This is a sequence of include and exclude glob patterns.
      #   - include:                              # Include patterns are evaluated fully first. All of them are
      #       - '**/build-txt.log                 # relative to the root of the source directory.
      #     exclude:                              # Exclude patterns are evaluated after all include patterns are evaluated.
      #       - '**/*.log'                        # There may be spurious log files. Exclude them.


    # The following commands (that use updateApplicationVersion.cmd) update manifest versions for service fabric (SF) applications.
    #
    # They expect the following arguments:
    # 1. applicationPackageDir: Path (relative to build agent root) of the directory containing the application package contents.
    #    The ApplicationManifest.xml should be directly in this directory;
    #    The ServiceManifest.xml files should be within each service's subdirectory.
    # 2. applicationName: A name to identify the SF application
    #    - This should match the template and parameter file prefix (eg: <applicationPkgName>.template.json)
    #    - This is also the name of the SfPkg that we want to create (<applicationPkgName>.sfpkg)
    # 3. armParametersDir: Path (relative to build agent's root directory) to the directory in which the ARM parameters files exist.
    #

    # Package the Synapse Insights fabric application
    - !!defaultcommand
      name: 'Update ServiceFabric Application Version - SynInsightsApp'
      command: '.pipelines\updateApplicationVersion.cmd'
      arguments: 'src\Services\Microsoft.Synapse.Insights.SfApplication\pkg\Release SynInsightsApp .pipelines\Deployment\Application\Parameters'
    
    # Package the FabricMonitoring service fabric application
    - !!defaultcommand
      name: 'Update ServiceFabric Application Version - FabricMonitoringApp'
      command: '.pipelines\updateApplicationVersion.cmd'
      arguments: 'src\Services\Microsoft.Synapse.Insights.Monitoring\bin\x64\Release\MonitoringServiceWithMA fabricMonitoringApp .pipelines\Deployment\Application\Parameters'
      
    # The following commands (that use updateRolloutSpecs.cmd) update the RolloutSpec with version information.
    # They also create the BuildVer.txt file used by the RolloutSpec during deployment.
    #
    # They expect the following argument(s):
    # 1. rolloutSpecsDir: Path (relative to build agent root) of the directory directory in which the RolloutSpec files exist.

    - !!defaultcommand
      name: 'Update RolloutSpecs - Cluster'
      command: '.pipelines\updateRolloutSpecs.cmd'
      arguments: '.pipelines\Deployment\Cluster\RolloutSpecs'

    - !!defaultcommand
      name: 'Update RolloutSpecs - Applications'
      command: '.pipelines\updateRolloutSpecs.cmd'
      arguments: '.pipelines\Deployment\Application\RolloutSpecs'

    - !!buildcommand
      name: 'Copy build artifiacts'
      command: '.pipelines\noOp.cmd'
      artifacts:
        - from: 'src\Services\Microsoft.Synapse.Insights.SfApplication\pkg'
          to: 'Microsoft.Synapse.Insights.SfApplication\pkg'
          include:
            - '**/*.*'
        - from: 'src\Services\Microsoft.Synapse.Insights.SfApplication\bin'
          to: 'Microsoft.Synapse.Insights.SfApplication\bin'
          include:
            - '**/*.*'
        - from: 'src\Services\Microsoft.Synapse.Insights.Monitoring\bin'
          to: 'Microsoft.Synapse.Insights.Monitoring\bin'
          include:
            - '**/*.*'            
        - from: '.pipelines\Deployment\Cluster'
          to: 'Cluster'
          include:
            - '**/*.json'
        - from: 'src\Services\Microsoft.Synapse.Insights.Test\bin'
          to: 'Microsoft.Synapse.Insights.Test\bin'
          include:
            - '**/*.*' 

        # Create the ServiceGroupRoot structure required for EV2
        - from: '.pipelines\Deployment\Cluster\Templates'
          to: 'ServiceGroupRoot\Templates'
          include:
            - '*.template.json'
        - from: '.pipelines\Deployment\Cluster\Parameters'
          to: 'ServiceGroupRoot\Parameters'
          include:
            - '*.parameters.*.json'
        - from: '.pipelines\Deployment\Cluster'
          to: 'ServiceGroupRoot'
          include:
            - '**/*.ServiceModel.*'
        - from: '.pipelines\Deployment\Cluster\RolloutSpecs'
          to: 'ServiceGroupRoot\RolloutSpecs'
          include:
            - '**/*.*'
        - from: '.pipelines\Deployment\Application\Templates'
          to: 'ServiceGroupRoot\Templates'
          include:
            - '**/*.*'
        - from: '.pipelines\Deployment\Application\Parameters'
          to: 'ServiceGroupRoot\Parameters'
          include:
            - '**/*.*'
        - from: '.pipelines\Deployment\Application'
          to: 'ServiceGroupRoot'
          include:
            - '**/*.ServiceModel.*'
        - from: '.pipelines\Deployment\Application\RolloutSpecs'
          to: 'ServiceGroupRoot\RolloutSpecs'
          include:
            - '**/*.*'
        - from: 'buildVersionDir'
          to: 'ServiceGroupRoot'
          include:
            - 'BuildVer.txt'

# An optional user defined stage for performing packaging. This exists as a separate stage because some build processes do a
# compile-sign-package-sign model. For example, Windows based builds use this model. Linux builds typically follow a
# compile-hash-package-hash-sign hash model. For those folks, package may not need to exist as a separate step.
# Eventually, network access will be limited or cut-off in this stage.
package:
  commands: # This is a sequence of script files to be executed one after another in the order they appear here.

    # The following commands (that use packageApplication.cmd) create the package archive for service fabric (SF) applications.
    #
    # They expect the following arguments:
    # 1. applicationPackageDir: Path (relative to build agent root) of the directory containing the application package contents.
    #    The ApplicationManifest.xml should be directly in this directory;
    #    The ServiceManifest.xml files should be within each service's subdirectory.
    # 2. applicationName: A name to identify the SF application
    #    - This should match the template and parameter file prefix (eg: <applicationPkgName>.template.json)
    #    - This is also the name of the SfPkg that we want to create (<applicationPkgName>.sfpkg)
    #
    # The resulting sfpkg in placed in the parent directory of <applicationPackageDir>, and is named <applicationName>.sfpkg.

    # Package the Synapse Insights service fabric application
    - !!defaultcommand
      name: 'Package ServiceFabric Application - SynInsightsApp'
      command: '.pipelines\packageApplication.cmd'
      arguments: 'src\Services\Microsoft.Synapse.Insights.SfApplication\pkg\Release SynInsightsApp'
    # Package the FabricMonitoring service fabric application
    - !!defaultcommand
      name: 'Package ServiceFabric Application - FabricMonitoringApp'
      command: '.pipelines\packageApplication.cmd'
      arguments: 'src\Services\Microsoft.Synapse.Insights.Monitoring\bin\x64\Release\MonitoringServiceWithMA fabricMonitoringApp'

    - !!buildcommand
      name: 'Copy build artifiacts'
      command: '.pipelines\noOp.cmd'
      artifacts:
        - from: '.pipelines\Deployment\Cluster\Templates'
          to: 'ServiceGroupRoot\Templates'
          include:
            - '*.template.json'
        - from: '.pipelines\Deployment\Cluster\Parameters'
          to: 'ServiceGroupRoot\Parameters'
          include:
            - '*.parameters.*.json'
        - from: '.pipelines\Deployment\Cluster'
          to: 'ServiceGroupRoot'
          include:
            - '**/*.ServiceModel.*'
        - from: '.pipelines\Deployment\Cluster\RolloutSpecs'
          to: 'ServiceGroupRoot\RolloutSpecs'
          include:
            - '**/*.*'
        - from: '.pipelines\Deployment\Application\Templates'
          to: 'ServiceGroupRoot\Templates'
          include:
            - '**/*.*'
        - from: '.pipelines\Deployment\Application\Parameters'
          to: 'ServiceGroupRoot\Parameters'
          include:
            - '**/*.*'
        - from: '.pipelines\Deployment\Application'
          to: 'ServiceGroupRoot'
          include:
            - '**/*.ServiceModel.*'
        - from: '.pipelines\Deployment\Application\RolloutSpecs'
          to: 'ServiceGroupRoot\RolloutSpecs'
          include:
            - '**/*.*'
        - from: 'buildVersionDir'
          to: 'ServiceGroupRoot'
          include:
            - 'BuildVer.txt'
        - from: 'src\Services\Microsoft.Synapse.Insights.SfApplication\pkg'
          to: 'ServiceGroupRoot\bin'
          include:
            - '*.sfpkg'
        - from: 'src\Services\Monitoring\bin\Release\netcoreapp2.2'
          to: 'ServiceGroupRoot\bin'
          include:
            - '*.sfpkg'
        - from: 'src\Services\PatchOrchestration\bin\Release'
          to: 'ServiceGroupRoot\bin'
          include:
            - '*.sfpkg'
            
# An optional user defined stage for running tests that need network access. Note that unit tests and others that do not need network access
# can be run in build or package stages itself. Any artifacts built in this stage will be separated out and will not be signed.
# However, we recommend that tests always be run in the test stage.
# Eventually, we may even skip test artifacts completely.
test:
  commands:                                                             # This is a sequence of script files to be executed one after another
                                                                        # in the order they appear here.
#   - !!testcommand                                                     # We are going to run tests and collect back the test results for
#                                                                       # for publishing
#     name: 'Test CSharp'                                               # If your test run does not have a name, this will be used.
#     command: '.pipeline\test.cmd csharp'                              # Script that runs tests.
#     testresults:                                                      # Sequence of entries indicating which test results files to collect.
#       - from: 'src\WindowsServerSample\VisualStudio'
#         title: 'Even-Odd-Tests'                                       # Test run title. Used by VSTS.
#         configuration: 'Debug'                                        # Optional build configuration.
#         platform: 'Debug'                                             # Optional build platform.
#         type: 'vstest'                                                # Test engine type. Used by VSTS. Supported values are JUnit, NUnit
#                                                                       # VSTest and xUnit.
#         include:                                                      # Sequence of glob patterns indicating which test results file to
#                                                                       # associate with this test run.
#           - '**\*.trx'                                                # Include all TRX files under any TestResults folder under the src
#                                                                       # folder.
#   - !!testcommand
#     name: 'Test Maven'
#     command: 'src\WindowsServerSample\Maven\test.cmd'
#     testresults:
#       - title: 'Mvn Junit Tests'
#         type: 'junit'
#         from: 'src\WindowsServerSample\Maven\target\surefire-reports'
#         include:
#           - "**/*.xml"

# An optional, interim user defined stage for performing publishing of the build. Examples include, dropping the files to a network share,
# pushing packages to a package repository, uploading binaries to blob store etc. 
# Eventually, network access in this stage will be restricted to dev-feeds only for
# non-official builds. We may remove this stage for official builds. Teams should use VSRM or Ev2 to release.
publish:
  commands:                                                             # This is a sequence of script files to be executed one after another
                                                                        # in the order they appear here.
                                                                        # We are not doing anything here. In fact, we could have omitted the
                                                                        # publish stage entirely.

# An optional user defined stage for running any type of always-needed uber cleanup. This exists as a separate stage because some build
# processes acquire shared resources during some stages. In case the build is cancelled or aborted or fails, this stage is provided so that
# these resources can be unacquired. In particular, the commands in this stage are always run.
#user_cleanup:
#  commands:                                                             # This is a sequence of script files to be executed one after another
                                                                        # in the order they appear here.
                                                                        # We are not doing anything here. In fact, we could have omitted the
                                                                        # user_cleanup stage entirely.

